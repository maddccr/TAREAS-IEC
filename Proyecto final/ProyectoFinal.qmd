---
title: "ProyectoFinal"
format: html
editor: visual
---

## Quarto

Simulacion de un modelo de crecimiento logistico mediante ABM

dN/dt = rN\[(K − N)/K\]

r = b-d o r = (b − d) + (i − e)

```{r}


#K --> capacidad de carga
#N --> cantidad de individuos // varia con el tiempo
#years --> numero de iteraciones OJO 
#Fijamos una tasa de muerte y natalidad ?.?


ABM <- function(K, iter, p_death, p_birth) {
  
  #Inicializar el ABM
  #Creacion del ambiente
  
  habSize <- ceiling(sqrt(K)) #quemos una grilla LxL que pueda ocupar K individuos
  L <- habSize^2
  habitat <- rep(0, L) #habitad vacia
  
  #Cantidad inicial de agentes (1%)
  N0 <- round(0.01 * K) #incorporar como parametro? 
  
  #Posicionar de forma aleatoria
  habitat[sample(1:L, N0)] <- 1 #1 = lleno
  
  #Lo que se busca monitonear es la cantidad de agentes en el tiempo
  N <- c() #crecieminto dinamico
  
  
  #ahora si
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) #recuperar los ind donde el hab esta ocupado
    
    #MUERTES: a cada agente vivo se le asigna una probabilidad a partir de una unif(0,1). Si p < p_death --> r.i.p
    
    for(agente in vivos){
      if( runif(1) < p_death){
        habitat[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    #para simular el compartamiento logistico es necesario que la p_birth sea controlada por la carga del ambiente
    
    n <- sum(habitat == 1) #sumamos los vivos
    p_birth_K <- p_birth*(1 - n / K) #por la limitaciones de la carga, a medida que aumenta N, disminuye la prob de nacer
    
    
    for(agent in vivos){
      if (runif(1) < p_birth_K){
        libres <- which(habitat == 0) #ind de espacios libres en la grilla
        if(length(libres) > 0){ 
        habitat[sample(libres, 1)]  <- 1 #elijo un ind aleatorio para colocar
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
  
    


    if(t %in% seq(1, iter - iter/2, by = 5)){
       habCuadrado <- matrix(habitat, nrow=habSize, byrow=TRUE)
       image(habCuadrado, col = c("white","black"), axes = FALSE, asp = 1)
    }


}
  
#intento de vizualizacion
  

  
return(N)
  
}


#arranca optima // abundancia de recursos 
N <- ABM(100, 60, 0.3, 0.8)


plot(N, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")

#graficar solucion de la edo y comparar con el modelo interpolado
t<- c(1:60)
ajuste <- loess(N ~ t, span = 0.2)
N_suavizado <- predict(ajuste)
plot(N_suavizado, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")


solucion_edo <- function(t, K, N0, r) {
  (K*N0*exp(r*t))/ (K + N0*(exp(r*t) - 1))
}

tiempos<- seq(0,60, by=1)
sols <- solucion_edo(tiempos, 100, 1, 0.5)
lines(tiempos, sols, type = "l")


#PROBAR ANIMAR / GIF O ELEGIR CORTES DE TIEMPO

```

```{r}

#EXTENDER EL MODELO AGREGANDO SEXO BIOLOGICO
ABM_ext1 <- function(K, iter, p_death, p_birth) {
  
  #Inicializar el ABM
  #Creacion del ambiente
  
  habSize <- ceiling(sqrt(K)) #quemos una grilla LxL que pueda ocupar K individuos
  L <- habSize^2
  habitat <- rep(0, L) #habitad vacia
  
  #Cantidad inicial de agentes (1%)
  N0 <- round(0.05 * K) #incorporar como parametro? 
  
  #PARA EVITAR EXTINCION SUBITA > 5%
  
  #Posicionar de forma aleatoria
  habitat[sample(1:L, N0)] <- 1 #1 = lleno
  
  #Lo que se busca monitonear es la cantidad de agentes en el tiempo
  N <- c() #crecieminto dinamico
  
  #INICIALIZAR LA EXTENCION
  bio_sex <- rep(NA, L)
  bio_sex[which(habitat ==1)] <- rbinom(N0, 1, 0.5)
  #a cada agente inicial le asigno un sexo bio (1= fem 0 = masc) con 50% de prob
  
  #ahora si
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) #recuperar los ind donde el hab esta ocupado
    
    #MUERTES: a cada agente vivo se le asigna una probabilidad a partir de una unif(0,1). Si p < p_death --> r.i.p
    
    for(agente in vivos){
      if( runif(1) < p_death){
        habitat[agente] <- 0
        bio_sex[agente] <- NA
      }
    }
    
    #NACIMIENTOS 
    #para simular el compartamiento logistico es necesario que la p_birth sea controlada por la carga del ambiente
    
    n <- sum(habitat == 1) #sumamos los vivos
    p_birth_K <- p_birth*(1 - n / K) #por la limitaciones de la carga, a medida que aumenta N, disminuye la prob de nacer
    
    
    for(agent in vivos){
      if(!is.na(bio_sex[agent]) & bio_sex[agent] == 1) {
        if (runif(1) < p_birth_K){
          libres <- which(habitat == 0) #ind de espacios libres en la grilla
          if(length(libres) > 0){ 
          i <- sample(libres, 1)
          habitat[i]  <- 1 #elijo un ind aleatorio para colocar
          bio_sex[i] <- rbinom(1, 1, 0.5)
          }
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    
    plot_grid <- rep(0, L)
    plot_grid[which(habitat == 1 & bio_sex == 0)] <- 1
    plot_grid[which(habitat == 1 & bio_sex == 1)] <- 2
    
    
    if(t %in% seq(1, iter - iter/2, by = 5)){
        
      habCuadrado <- matrix(plot_grid, nrow=habSize, byrow=TRUE)
      image(habCuadrado, col = c("white", "pink", "purple"), axes = FALSE, asp = 1)
      #title(main = paste("Iteración", t, " - N =", N[length(N)]))
    }
  
}
  
#intento de vizualizacion
  

  
return(N)
  
}


N <- ABM_ext(1000, 60, 0.3, 0.9)


plot(N, type="l", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")


#1000 03 - 09 extincion


```

EXTENCION EDAD

```{r}

ABM_ext2 <- function(K, iter, p_death, p_birth, r = 1) {
  
  #Inicializar el ABM
  #Creacion del ambiente
  
  habSize <- ceiling(sqrt(K)) #quemos una grilla LxL que pueda ocupar K individuos
  L <- habSize^2
  habitat <- rep(0, L) #habitad vacia
  
  #Cantidad inicial de agentes (1%)
  N0 <- round(0.01 * K) #incorporar como parametro? 
  
  #Posicionar de forma aleatoria
  habitat[sample(1:L, N0)] <- 1 #1 = lleno
  
  #Lo que se busca monitonear es la cantidad de agentes en el tiempo
  N <- c() #crecieminto dinamico
  
  edad <- rep(0, L) 
  #los N0 arrancan tambien con edad cero "recien colocado", se podria asignar una edad aleatroia
  #la edad maxima es la cantidad de iteraciones / lapso max de tiempo
  
  #ahora si
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) #recuperar los ind donde el hab esta ocupado
    
    #ENVEJECER 
    edad[vivos] <- edad[vivos] + 1
    
    
    #MUERTES: a cada agente vivo se le asigna una probabilidad a partir de una unif(0,1). Si p < p_death --> r.i.p
    
    
    for(agente in vivos){
      
       #riesgo: p_death base * (1 + a * edad / edad_max) // edad_max = iter
      p_death_eff <- p_death * (1 + r * (edad[agente] / iter))
      p_death_eff <- min(p_death_eff, 1)  # evitar >1
      
      if( runif(1) < p_death_eff){
        habitat[agente] <- 0
        edad[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    #para simular el compartamiento logistico es necesario que la p_birth sea controlada por la carga del ambiente
    
    n <- sum(habitat == 1) #sumamos los vivos
    p_birth_K <- p_birth*(1 - n / K) #por la limitaciones de la carga, a medida que aumenta N, disminuye la prob de nacer
    
    
    for(agent in vivos){
      if (runif(1) < p_birth_K){
        libres <- which(habitat == 0) #ind de espacios libres en la grilla
        if(length(libres) > 0){ 
          i <- sample(libres, 1)
          habitat[i]  <- 1 #elijo un ind aleatorio para colocar
          edad[i] <- 0
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
  
    


    if(t %in% seq(1, iter - iter/2, by = 5)){
       habCuadrado <- matrix(habitat, nrow=habSize, byrow=TRUE)
       image(habCuadrado, col = c("white","black"), axes = FALSE, asp = 1)
    }


}
  
#intento de vizualizacion
  

  
return(N)
  
}

N <- ABM_ext2(100, 60, 0.3, 0.8)


plot(N, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")




```

```{r}

#EXTENDER EL MODELO AGREGANDO SEXO BIOLOGICO y EDAD
ABM_ext3 <- function(K, iter, p_death, p_birth, r = 1, plot = FALSE) {
  
  habSize <- ceiling(sqrt(K))
  L <- habSize^2
  habitat <- rep(0, L)
  N0 <- round(0.05 * K) 
  
  
  habitat[sample(1:L, N0)] <- 1 
  N <- c() 
  bio_sex <- rep(NA, L)
  bio_sex[which(habitat ==1)] <- rbinom(N0, 1, 0.5)
  edad <- rep(0, L) 
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) 
    
    #ENVEJECER 
    edad[vivos] <- edad[vivos] + 1
    
    #MUERTE
    
    for(agente in vivos){
      
      p_death_eff <- p_death * (1 + r * (edad[agente] / iter))
      p_death_eff <- min(p_death_eff, 1)  
      
      if( runif(1) < p_death){
        habitat[agente] <- 0
        bio_sex[agente] <- NA
        edad[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    
    n <- sum(habitat == 1) 
    p_birth_K <- p_birth*(1 - n / K) 
    
    for(agent in vivos){
      if(!is.na(bio_sex[agent]) & bio_sex[agent] == 1) {
        if (runif(1) < p_birth_K){
            libres <- which(habitat == 0) 
            if(length(libres) > 0){ 
              i <- sample(libres, 1)
              habitat[i]  <- 1 
              bio_sex[i] <- rbinom(1, 1, 0.5)
              edad[i] <- 0
            }
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    
    if(plot) {
    
    plot_grid <- rep(0, L)
    plot_grid[which(habitat == 1 & bio_sex == 0)] <- 1
    plot_grid[which(habitat == 1 & bio_sex == 1)] <- 2
    
    
    if(t %in% seq(1, iter - iter/2, by = 5)){
        
      habCuadrado <- matrix(plot_grid, nrow=habSize, byrow=TRUE)
      image(habCuadrado, col = c("white", "pink", "purple"), axes = FALSE, asp = 1)
      #title(main = paste("Iteración", t, " - N =", N[length(N)]))
    }
    
    }
  
}
  
return(N)
  
}


N <- ABM_ext3(1000, 60, 0.1, 0.9)


plot(N, type="l", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")


```

ANALISIS DE SENSIBILIDAD

Barrido con p_death variable y p_birth fijo (0.9)

```{r}

set.seed(1234)

sensibilidad <- function(K = 1000, iter = 100, p_birth = 0.9, reps = 50){
  
  p_death <- seq(0, 0.5, by = 0.05)
  p_len <- length(p_death) #cauntos valores distintos de p
  
  #Monitorear
  extincion <- numeric(p_len)
  t_hasta_ext_prom <- numeric(p_len)
  
  #PARA LUEGO GRAFICAR NECESITAMOS PROMEDIAR LAS REPS
  mean_N <- matrix(0, nrow = iter, ncol = p_len)
  var_N <- matrix(0, nrow = iter, ncol = p_len)
  
  
  for(i in 1:p_len) {
    
    pd <- p_death[i]
    #guardar la serie de cada corrida
    runs <- matrix(NA, nrow = reps, ncol = iter)
    
    t_ext <- rep(Inf, reps) #si no extincion t = Inf
    
    for(r in 1:reps){
      N_t <- ABM_ext3(K, iter, pd, p_birth)
      runs[r, ] <- N_t
      
       if(any(N_t == 0)) { #primer instante donde la poblacion = 0
        t_ext[r] <- which(N_t == 0)[1]
      }
    }
    
     extincion[i] <- mean(t_ext < Inf)
     t_hasta_ext_prom[i] <- ifelse(all(extincion[i] == 0), 
                                  NA, 
                                  mean(t_ext[t_ext < Inf]))
     
     mean_N[ ,i] <- colMeans(runs)
     var_N[ ,i] <- apply(runs, 2, var)
    
  }
  
   list(p_death = p_death,
       mean_N = mean_N,
       var_N = var_N,
       extincion_prob = extincion,
       t_hasta_ext_prom = t_hasta_ext_prom)
 
}

#sensibilidad()


```

```{r}
#INTENTAR GRAFICAR CURVA 3D
```
