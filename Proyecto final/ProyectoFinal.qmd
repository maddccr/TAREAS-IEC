---
title: "ProyectoFinal"
format: html
editor: visual
---

## Proyecto Final - IEC 2025

# *Simulación de un modelo de crecimiento logístico mediante ABM*

## ABM - Base

```{r, warning=FALSE, message=FALSE}
#librerias
library(tidyverse)
library(parallel)
library(viridis)
set.seed(1234)
```

```{r}

ABM_base <- function(K, iter, p_death, p_birth, plot = FALSE) {
#K --> capacidad de carga del ambiente 
#iter --> numero de iteraciones // pasos de tiempo
#p_birth y p_death probabilidad inicial de reproduccion y muerte 
#N --> cantidad de individuos (variable de salida)
  
  #Inicializar el ABM
  #Creacion del ambiente
  
  habSize <- ceiling(sqrt(K)) #quemos una grilla LxL que pueda ocupar K individuos
  L <- habSize^2
  habitat <- rep(0, L) #habitad vacia
  
  #Cantidad inicial de agentes (1%)
  N0 <- round(0.01 * K) #se podria incorporar como parametro
  
  #Posicionar de forma aleatoria
  habitat[sample(1:L, N0)] <- 1 #1 = lleno
  
  #Lo que se busca monitonear es la cantidad de agentes en el tiempo
  N <- c() #crecieminto dinamico
  p_b <- c() #registrar variacion de la p_birth efectiva

  
  #ahora si
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) #recuperar los indices donde el hab esta ocupado
    
    #MUERTES: a cada agente vivo se le asigna una probabilidad a partir de una unif(0,1). Si p < p_death --> r.i.p (equivalente a una ber(p))
    
    for(agente in vivos){
      if( runif(1) < p_death){
        habitat[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    #para simular el compartamiento logistico es necesario que la p_birth sea controlada por la carga del ambiente
    
    n <- sum(habitat == 1) #sumamos los vivos
    p_birth_K <- p_birth*(1 - n / K) #por la limitaciones de la carga, a medida que aumenta N, disminuye la prob de reproducirse
    
    
    for(agent in vivos){
      if (runif(1) < p_birth_K){
        libres <- which(habitat == 0) #ind de espacios libres en la grilla
        if(length(libres) > 0){ 
        habitat[sample(libres, 1)]  <- 1 #elijo un ind aleatorio para colocar
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    p_b <- c(p_b, p_birth_K)
  
    if(plot){ #graficar para cortes de tiempo // se ve como un QR:(
      if(t %in% seq(1, iter - iter/2, by = 5)){
         habCuadrado <- matrix(habitat, nrow=habSize, byrow=TRUE)
         image(habCuadrado, col = c("white","black"), axes = FALSE, asp = 1)
      }
    }

  }
  
df_N <- data.frame(N = N,
                   p = p_b,
                   t = 1:iter)

return(list( N = N,
             p_birth_eff = p_b,
             df_N = df_N))  
  
}



```

```{r}

ABM_1 <- ABM_base(100, 60, 0.1, 0.9)
#los parametros que contralan la mortalidad y la natalidad los inicializamos de forma optima, dado que van a ir "empeorando" con el tiempo
ABM_2 <- ABM_base(100, 60, 0.3, 0.8)

df <- bind_rows(
  ABM_1$df_N |>  mutate(simu = "pD=0.1, pB=0.9"),
  ABM_2$df_N |>  mutate(simu = "pD=0.3, pB=0.8")
)

ggplot(df) + geom_point(aes(x = t, y = N, color = simu, shape = "N")) +
  geom_point(aes(x = t, y = p*max(N), color = simu, shape = "pB efectiva"),
             size = 0.8) +
  labs(title = "ABM base - Evolucion de la poblacion", x = "Tiempo", 
       y = "Población N(t)\n Probabilida de reproduccion (%)", 
       color = "Parametros") +
  scale_color_manual( values = viridis(20)[c(2,13)], name = "Simulación") +
  #scale_color_viridis(discrete = TRUE, option = "D") +
  scale_shape_manual(values = c("N" = 16, "pB efectiva" = 17),
    name = "Variable") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
        legend.position = "bottom")
 


```

Solucion de la EDO

```{r}

#Primero suavizamos con metodo LOESS
t <- ABM_1$df_N$t
ajuste <- loess(ABM_1$N ~ t, span = 0.2)
ABM_1_suavizado <- predict(ajuste)

#Plot pasico para registrar resultados
plot(ABM_1_suavizado, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM Base")

#La EDO tiene sol analitica
sol_EDO <- function(t, K, N0, r) {
  (K*N0*exp(r*t))/ (K + N0*(exp(r*t) - 1))
}

sols <- sol_EDO(t, 100, 1, 0.8) #r = pB - pD
lines(t, sols, type = "l")

```

```{r}
#Para paremtros optimos realizamos n replicas

simulacion_n <- function(n){
  sims <- matrix(NA, nrow = n, ncol = 60) #iter = 60
  for (i in 1:n) {
    res <- ABM_base(100, 60, 0.1, 0.9)
    sims [i, ] <- res$N
  }
  return(sims)
}

sim <- simulacion_n(30)

#INTERPOLACION
interpolar_sims <- function(sims) {
  n <- nrow(sims)
  t <- 1:ncol(sims)
  interpolated <- matrix(NA, nrow = n, ncol = 200)
  for (i in 1:n) {
    new_points<- spline(t, sims[i,], 200)
    interpolated [i,] <- new_points$y
  }
  return(interpolated)
}

```

```{r}

df_sim1 <- data.frame(
  t = 1:length(sim[1, ]),
  N = sim[1, ]
)

df_EDO <- data.frame(
  t = t,
  N_EDO = sols
)

sim_matrix <- sim_splines # matriz nSim x nPuntos (200)
t200 <- seq(1, 60, length.out = 200)

# Calcular percentiles
ribbon_df <- data.frame(
  t = t200,
  ymin = apply(sim_splines, 2, quantile, probs = 0.1),
  ymax = apply(sim_splines, 2, quantile, probs = 0.9)
)

df_spline <- sim_splines |> as.data.frame() |> setNames(1:200) |> 
  mutate(sim = row_number()) |> 
  pivot_longer(cols = -sim, names_to = "index", values_to = "N_interp") |> 
  mutate(index = as.numeric(index),t = seq(1, 60, length.out = 200)[index])

ggplot() + geom_point(data = df_sim1, size = 1, alpha = 0.8,
    aes(x = t, y = N, color = "ABM Base")) +
           geom_line(data = df_spline |>  filter(sim == 1), size = 1,
    aes(x = t, y = N_interp, color = "Interpolacion")) +
  
    scale_color_manual(values = viridis(20)[c(2, 13)],name = "") +
    labs(title = "Simulación (1): Original vs Interpolacion", 
          x = "Tiempo", y = "Población N(t)") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
    legend.position = "bottom")

ggplot() +
  geom_ribbon(data = ribbon_df, aes(x = t, ymin = ymin, ymax = ymax),
              fill = viridis(20)[20], alpha = 0.5) +
  geom_line(data = df_spline, aes(x = t, y = N_interp, group = sim, color = sim),    alpha = 0.7) +
  geom_line(data = df_EDO, aes(x = t, y = N_EDO),
            color = "black", size = 0.7) +
  
  scale_color_viridis_c(end = 0.8) +
  labs(title = "Todas las simulaciones interpoladas (spline)",
       x = "Tiempo",y = "Población interpolada") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
    legend.position = "right")

```

```{r}
#coeficientes de los splines
coef_splines <- function(sims) {
  n <- nrow(sims)
  t <- 1:ncol(sims)
  interpolated <- vector("list", n)
  poly_spline <- vector("list", n)
  coefs <- vector("list", n)
  
  for (i in 1:n) {
    interpolated[[i]] <- interpSpline(t, sims[i,]) # spline cúbica en base B
    coefs[[i]] <- coef(interpolated[[i]]) # coeficientes a, b, c, d
  }
  
  return(coefs)
}

coeficientes <- coef_splines(sim)
coeficientes[1]

plot(coeficientes_5[[2]][,2])
points(coeficientes_5[[2]][,3], pch=21, bg = "red")
#points(coeficientes_5[[2]][,4], pch=21, bg = "blue")
```

## ABM - Extendido (edad y sexo biologico)

```{r}
ABM_ext <- function(K, iter, p_death, p_birth, r = 1, plot = FALSE) {
  
  timestamps <- c(1, 4, 7, 10, 13, 16, 19, 21, iter)
  timestamps_plot <- list()
  
  
  habSize <- ceiling(sqrt(K))
  L <- habSize^2
  habitat <- rep(0, L)
  
  N0 <- round(0.05 * K) #Para evitar extincion subita inicamos con mas agentes
  
  habitat[sample(1:L, N0)] <- 1 
  N <- c() 
  
  #a cada agente inicial le asigno un sexo bio (1= fem 0 = masc) con ber(0.5)
  bio_sex <- rep(NA, L)
  bio_sex[which(habitat ==1)] <- rbinom(N0, 1, 0.5)
  
  #los N0 arrancan tambien con edad cero "recien colocado"
  #la edad maxima es la cantidad de iteraciones / lapso max de tiempo
  edad <- rep(0, L) 
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) 
    
    #ENVEJECER 
    edad[vivos] <- edad[vivos] + 1
    
    #MUERTE
    
    for(agente in vivos){
       #riesgo: p_death base * (1 + r * edad / edad_max) // edad_max = iter
      p_death_eff <- p_death * (1 + r * (edad[agente] / iter))
      p_death_eff <- min(p_death_eff, 1)  # evitar >1
      
      if( runif(1) < p_death){
        habitat[agente] <- 0
        bio_sex[agente] <- NA
        edad[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    
    n <- sum(habitat == 1) 
    p_birth_K <- p_birth*(1 - n / K) 
    
    for(agent in vivos){
      if(!is.na(bio_sex[agent]) & bio_sex[agent] == 1) {
        if (runif(1) < p_birth_K){
            libres <- which(habitat == 0) 
            if(length(libres) > 0){ 
              i <- sample(libres, 1)
              habitat[i]  <- 1 
              bio_sex[i] <- rbinom(1, 1, 0.5)
              edad[i] <- 0
            }
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    
    if(plot) {
    
    plot_grid <- rep(0, L)
    plot_grid[which(habitat == 1 & bio_sex == 0)] <- 1
    plot_grid[which(habitat == 1 & bio_sex == 1)] <- 2
    
    
    if(t %in% timestamps){
        
      habCuadrado <- matrix(plot_grid, nrow=habSize, byrow=TRUE)
      timestamps_plot[[as.character(t)]] <- list(grid = habCuadrado)
      #title(main = paste("Iteración", t, " - N =", N[length(N)]))
    }
    
    }
  
}
  
return(list(N = N, plot = timestamps_plot))
  
}

```

```{r}
K <- 500
ABM_3 <- ABM_ext(K, 60, 0.1, 0.9, plot = TRUE)

par(mfrow=c(3,3), mar=c(2,2,2,2))
for(name in names(ABM_3$plot)){
  
  grid <- ABM_3$plot[[name]]$grid
  
  image(grid[nrow(grid):1,], col=c("white", viridis(20)[2], viridis(20)[13]), 
        axes=FALSE, asp = 1)
  title(paste("t =", name))
  
  # Calcular %
  n_SM <- sum(grid == 1)
  n_SF <- sum(grid == 2)
  n_total <- n_SM + n_SF
  ocupacion <- round(100 * n_total / K, 1)
  prop_SM <- round(100 * n_SM / n_total, 1)
  prop_SF <- round(100 * n_SF / n_total, 1)
  
    # Texto debajo en negrita
  mtext(paste0("N/K: ", ocupacion, "% | SM: ", prop_SM,
               "% | SF: ", prop_SF, "%"), side=1, line=0.5, cex=0.65, font=2)
  legend("bottomright", legend=c("SM","SF"), 
         fill= c(viridis(20)[2], viridis(20)[13]), bty="n", cex=0.8)
}

```

```{r}
#GRAFICAR CURVA
```

### Analisis de sensibilidad 

PARALELIZAR

```{r}
#Barrido con p_death variable y p_birth fijo (0.9)
#arrancar con 10
sens_paral <- function(K = 500, iter = 60, p_birth = 0.9, reps = 50, 
                       p_death = seq(0, 0.5, by = 0.05)) {
  
  t0 <- Sys.time()
  p_len <- length(p_death)
  
  cores <- detectCores() - 1
  cl <- makeCluster(cores)
  
  #Exportar funciones necesarias
  clusterExport(cl,varlist = c("ABM_ext"),envir = .GlobalEnv)
  #clusterSetRNGStream(cl, iseed = seed)
  
  #Monitorear
  extincion <- numeric(p_len)
  t_hasta_ext_prom <- numeric(p_len)
  
  #PARA LUEGO GRAFICAR NECESITAMOS PROMEDIAR LAS REPS (punto a punto)
  mean_N <- matrix(0, nrow = iter, ncol = p_len)
  var_N <- matrix(0, nrow = iter, ncol = p_len)
  
  for (i in 1:p_len) {
    pd <- p_death[i]
    
    #Ejecutar reps en paralelo
    runs_list <- parLapply(cl, 1:reps, function(r) {
      ABM_ext(K = K, iter = iter, p_death = pd, p_birth = p_birth)$N
    })
    
    #Pasar lista a matriz reps × iter
    runs <- do.call(rbind, runs_list)
    
    mean_N[ ,i] <- colMeans(runs)
    var_N[ ,i]  <- apply(runs, 2, var)
    
    #Extinción
    t_ext <- apply(runs, 1, function(x) {
      if(any(x == 0)) which(x == 0)[1] else Inf
    })
    
    extincion[i] <- mean(t_ext < Inf)
    t_hasta_ext_prom[i] <- ifelse(all(extincion[i] == 0), 
                                  NA, 
                                  mean(t_ext[t_ext < Inf]))
  }
  
  stopCluster(cl)
  
  list(p_death = p_death,
       mean_N = mean_N,
       var_N = var_N,
       extincion_prob = extincion,
       t_hasta_ext_prom = t_hasta_ext_prom,
       t_eje = (t0 - Sys.time()))
}


```

```{r, warning=FALSE}

res05 <- sens_paral()
res01 <- sens_paral(p_death = seq(0.2, 0.35, by = 0.005), iter = 100)
```

```{r}

#Mean_N es una matriz --> pasar a formato long
df_long <- data.frame(
  time = rep(1:nrow(res05$mean_N), times = length(res05$p_death)),
  p_death = rep(res05$p_death, each = nrow(res05$mean_N)),
  mean = as.vector(res05$mean_N),
  var = as.vector(res05$var_N)
)

df_long <- data.frame(
  time = rep(1:nrow(res01$mean_N), times = length(res01$p_death)),
  p_death = rep(res01$p_death, each = nrow(res01$mean_N)),
  mean = as.vector(res01$mean_N),
  var = as.vector(res01$var_N)
)


ggplot(df_long, aes(x = time, y = mean, color = p_death, group = p_death)) +
  geom_line(size = 0.8) +
  labs(color = "p_death",
       x = "Tiempo",
       y = "Población promedio",
       title = "Crecimiento poblacional para distintos p_death") +
  scale_color_viridis_c(option = "D") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
        legend.position = "right")







```

```{r, warning=FALSE}

#dos dimension con IC!!! buscar formato 
#cortar en un tiempo // la banda!! 
#HACER ZOOM EN 2-3 

#plot(N, type="p", 
#xlab="Tiempo", ylab="Población N(t)",
#main="ABM - Crecimiento Logístico")
#PASAR A 2D CON COLOR! INCLUIR IC 
#Visualizacion


#Mean_N es una matriz --> pasar a formato long

# IC del 95% # n = reps = 50
df_long <- df_long |> 
  mutate(
    sd = sqrt(var),
    se = sd / sqrt(50), #error standar                    
    IC_l = mean - 1.96*se,
    IC_u  = mean + 1.96*se
  )


ggplot(df_long, aes(x = time, y = mean, color = as.factor(p_death), fill = as.factor(p_death))) +
  geom_line(size = 0.5) +
  geom_ribbon(aes(ymin = IC_l, ymax = IC_u), alpha = 0.15, color = NA) +
  labs(color = "p_death", fill = "p_death",
       x = "Tiempo",
       y = "Población promedio ± IC95%",
       title = "Curvas con intervalos de confianza") +
  theme_minimal()



#suavizar con loess
```

```{r}
#Graficar el p_birth_eff, p_death_eff
#SENSIBILIDAD MULTIVARIADA CON CORTE TRANSVERSAL
#OJO CON LAS REPS




```
