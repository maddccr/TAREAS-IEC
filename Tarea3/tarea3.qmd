---
title: "tarea3"
format: html
editor: visual
---

Ejercicio 8

Modificacion de la funcion fixedpoint (10.2) para funciones de Rd en Rd. Cambiamo la funcion abs() por norm()

```{r}

#funcion sacada del libro:
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {

 # applies the fixed-point algorithm to find x such that ftn(x) == x
 # ftn  R^d -> R^d, d > 1.
 # x0 is the initial guess at the fixed point
 #LA FUNCION NORM CALCULA LA NORMA DE VECTORES
 
 xold <- x0
 xnew <- ftn(xold)
 iter <- 1
 cat("At iteration 1 value of x is:", xnew, "\n")
 #modificamos abs por norm
 while ((norm(as.matrix(xnew-xold)) > tol) && (iter < max.iter)) {
 xold <- xnew;
 xnew <- ftn(xold);
 iter <- iter + 1
 cat("At iteration", iter, "value of x is:", xnew, "\n")
 }
 # output depends on success of algorithm
 if (norm(as.matrix(xnew-xold)) > tol) {
 cat("Algorithm failed to converge\n")
 return(NULL)
 } else {
 cat("Algorithm converged\n")
 return(xnew)
 }
}

#definir la funcion para evaluar
f <- function(x){
  c(log(1 + x[1] + x[2]), log(5 - x[1] - x[2]))
}

x0 <- c(1,1)

fixedpoint(f, x0)
```

Ejercicio 6 - secant method

```{r}

secant <- function(ftn, x0, x1, tol = 1e-9, max.iter = 100) {
 

 xold1 <- x0
 xold2 <- x1
 xnew <- ftn(x1)
 
 iter <- 1
 #modificamos abs por norm
 while ((abs(ftn(xnew)) > tol) && (iter < max.iter)) {
 xnew <- xold2 - ftn(xold2)*((xold2 - xold1)/(ftn(xold2) - ftn(xold1)))
 xold1 <- xold2
 xold2 <- xnew
 iter <- iter + 1
 cat("At iteration", iter, "value of x is:", xnew, "\n")
 }
 # output depends on success of algorithm
 if ((abs(ftn(xnew)) > tol)) {
 cat("Algorithm failed to converge\n")
 return(NULL)
 } else {
 cat("Algorithm converged\n")
 return(xnew)
 }
}

f <- function(x) cos(x) - x
f1 <- function(x) log(x) - exp(-x)

secant(f, 1, 3)
secant(f1, 1, 2)

```

Comparar performe con la funcion de NR

```{r}

#FUNCION DEL LIBRO
newtonraphson <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
 # Newton_Raphson algorithm for solving ftn(x)[1] == 0
 # we assume that ftn is a function of a single variable that returns
 # the function value and the first derivative as a vector of length 2
 #
 # x0 is the initial guess at the root
 # the algorithm terminates when the function value is within distance
 # tol of 0, or the number of iterations exceeds max.iter
 # initialise
 x <- x0
 fx <- ftn(x)
 iter <- 0
 # continue iterating until stopping conditions are met
 while ((abs(fx[1]) > tol) && (iter < max.iter)) {
 x <- x- fx[1]/fx[2]
 fx <- ftn(x)
 iter <- iter + 1
 cat("At iteration", iter, "value of x is:", x, "\n")
 }
 # output depends on success of algorithm
 if (abs(fx[1]) > tol) {
 cat("Algorithm failed to converge\n")
 return(NULL)
 } else {
 cat("Algorithm converged\n")
 return(x)
 }
}

f <- function(x) {
 fx <- cos(x) - x
 dfx <- -sin(x) -1
 return(c(fx, dfx))
 }

f1 <- function(x) {
 fx <- log(x)- exp(-x)
 dfx <- 1/x + exp(-x)
 return(c(fx, dfx))
 }

newtonraphson(f, 1) 
newtonraphson(f1, 1) 
```

Ejercicio 5

Hallar raices de funciones con newtonraphson_show

```{r}
newtonraphson_show <- function(ftn, x0, xmin = x0-1, xmax = x0+1) {
  # applies Newton-Raphson to find x such that ftn(x)[1] == 0
  # x0 is the starting point
  # subsequent iterations are plotted in the range [xmin, xmax]
  # plot the function
  x <- seq(xmin, xmax, (xmax - xmin)/200)
  fx <- c()
  for (i in 1:length(x)) {
    fx[i] <- ftn(x[i])[1]
  }
  plot(x, fx, type = "l", xlab = "x", ylab = "f(x)",
       main = "zero f(x) = 0", col = "blue", lwd = 2)
  lines(c(xmin, xmax), c(0, 0), col = "blue")
  # do first iteration
  xold <- x0
  f.xold <- ftn(xold)
  xnew <- xold - f.xold[1]/f.xold[2]
  lines(c(xold, xold, xnew), c(0, f.xold[1], 0), col = "red")
  # continue iterating while user types "y"
  cat("last x value", xnew, " ")
  continue <- readline("continue (y or n)? ") == "y"
  while (continue) {
    xold <- xnew;
    f.xold <- ftn(xold)
    xnew <- xold - f.xold[1]/f.xold[2]
    lines(c(xold, xold, xnew), c(0, f.xold[1], 0), col = "red")
    cat("last x value", xnew, " ")
    continue <- readline("continue (y or n)? ") == "y"
  }
  return(xnew)
}


a <- function(x) c(cos(x) - x, -sin(x) - 1)
newtonraphson_show(a,1)
newtonraphson_show(a,3)
newtonraphson_show(a,6)

b <- function(x) c(log(x) - exp(-x), 1/x + exp(-x))
newtonraphson_show(b,2)

ce <- function(x) c(x^3 - x - 3, 3*x^2 - 1)
newtonraphson_show(ce,0) #diverge
newtonraphson_show(ce,2) #converge a 1.6717

d <- function(x) c(x^3 - 7*x^2 + 14*x - 8, 3*x^2 - 14*x + 14)
for (i in seq(1.1, 1.9, by = 0.1)) {
  newtonraphson_show(d, i, xmin = i - 0.5, xmax = i + 0.5)
}
#Las distintas condiciones iniciales convergen a distintas raices

e <- function(x) c(log(x)*exp(-x), exp(-x)*(1/x - log(x)))
newtonraphson_show(e, 2) #diverge
newtonraphson_show(e, 0.5) #converge a 1
```
