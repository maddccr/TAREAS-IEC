---
title: "ProyectoFinal"
format: html
editor: visual
---

## Quarto

Simulacion de un modelo de crecimiento logistico mediante ABM

dN/dt = rN\[(K − N)/K\]

r = b-d o r = (b − d) + (i − e)

#arranca optima // abundancia de recursos

N \<- ABM(100, 60, 0.3, 0.8)

plot(N\$N, type="p",

xlab="Tiempo", ylab="Población N(t)",

main="ABM - Crecimiento Logístico")

points((N\$p_birth_eff)\*100, col= "red")

N\$p_birth_eff

```{r}


#K --> capacidad de carga
#N --> cantidad de individuos // varia con el tiempo
#iter --> numero de iteraciones // pasos de tiempo
#p_birth y p_death probabilidad inicial de reproduccion y muerte


ABM <- function(K, iter, p_death, p_birth) {
  
  #Inicializar el ABM
  #Creacion del ambiente
  
  habSize <- ceiling(sqrt(K)) #quemos una grilla LxL que pueda ocupar K individuos
  L <- habSize^2
  habitat <- rep(0, L) #habitad vacia
  
  #Cantidad inicial de agentes (1%)
  N0 <- round(0.01 * K) #incorporar como parametro? 
  
  #Posicionar de forma aleatoria
  habitat[sample(1:L, N0)] <- 1 #1 = lleno
  
  #Lo que se busca monitonear es la cantidad de agentes en el tiempo
  N <- c() #crecieminto dinamico
  p_b <- c()

  
  
  #ahora si
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) #recuperar los ind donde el hab esta ocupado
    
    #MUERTES: a cada agente vivo se le asigna una probabilidad a partir de una unif(0,1). Si p < p_death --> r.i.p
    
    for(agente in vivos){
      if( runif(1) < p_death){
        habitat[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    #para simular el compartamiento logistico es necesario que la p_birth sea controlada por la carga del ambiente
    
    n <- sum(habitat == 1) #sumamos los vivos
    p_birth_K <- p_birth*(1 - n / K) #por la limitaciones de la carga, a medida que aumenta N, disminuye la prob de nacer
    
    
    for(agent in vivos){
      if (runif(1) < p_birth_K){
        libres <- which(habitat == 0) #ind de espacios libres en la grilla
        if(length(libres) > 0){ 
        habitat[sample(libres, 1)]  <- 1 #elijo un ind aleatorio para colocar
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    p_b <- c(p_b, p_birth_K)
  
    


    if(t %in% seq(1, iter - iter/2, by = 5)){
       habCuadrado <- matrix(habitat, nrow=habSize, byrow=TRUE)
       image(habCuadrado, col = c("white","black"), axes = FALSE, asp = 1)
    }


}


return(list( N = N,
             p_birth_eff = p_b))  
  
}


#PROBAR ANIMAR / GIF O ELEGIR CORTES DE TIEMPO

```

```{r}
#arranca optima // abundancia de recursos 
N <- ABM(100, 60, 0.3, 0.8)
#Probar 01 y 09


plot(N$N, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")
points((N$p_birth_eff)*100, col= "red")


```

```{r}
#graficar solucion de la edo y comparar con el modelo interpolado
t<- c(1:60)
ajuste <- loess(N$N ~ t, span = 0.2)
N_suavizado <- predict(ajuste)
plot(N_suavizado, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")


solucion_edo <- function(t, K, N0, r) {
  (K*N0*exp(r*t))/ (K + N0*(exp(r*t) - 1))
}

tiempos<- seq(0,60, by=1)
sols <- solucion_edo(tiempos, 100, 1, 0.5)
lines(tiempos, sols, type = "l")



#simulaciones repetidas

set.seed(1234)

simulacion_n <- function(n){
  sims <- matrix(NA, nrow = n, ncol = 60)
  for (i in 1:n) {
    res <- ABM(100, 60, 0.3, 0.8)
    sims [i, ] <- res$N
  }
  return(sims)
}

sim <- simulacion_n(30)

#grafico de simulaciones

plot(sim[1,], col="blue")
points(sim[2,], col="red")
points(sim[3,], col="yellow")
points(sim[4,], col="green")
points(sim[5,], col="violet")
points(sim[6,], col="blue")
points(sim[7,], col="red")
points(sim[8,], col="yellow")
points(sim[9,], col="green")
points(sim[10,], col="violet")

#interpolacion
interpolar_sims <- function(sims) {
  n <- nrow(sims)
  t <- 1:ncol(sims)
  interpolated <- matrix(NA, nrow = n, ncol = 200)
  for (i in 1:n) {
    new_points<- spline(t, sims[i,], 200)
    interpolated [i,] <- new_points$y
  }
  return(interpolated)
}

sim_splines <- interpolar_sims(sim)

#grafico de interpolados
plot(sim_splines[1,], col="blue", pch=18)
points(sim_splines[2,], col="red", pch=18)
points(sim_splines[3,], col="yellow",pch=18)
points(sim_splines[4,], col="green", pch=18)
points(sim_splines[5,], col="violet", pch=18)
points(sim_splines[6,], col="blue", pch=18)
points(sim_splines[7,], col="red",pch=18)
points(sim_splines[8,], col="yellow", pch=18)
points(sim_splines[9,], col="green", pch=18)
points(sim_splines[10,], col="violet", pch=18)

#coeficientes de los splines
coef_splines <- function(sims) {
  n <- nrow(sims)
  t <- 1:ncol(sims)
  interpolated <- vector("list", n)
  poly_spline <- vector("list", n)
  coefs <- vector("list", n)
  
  for (i in 1:n) {
    interpolated[[i]] <- interpSpline(t, sims[i,]) # spline cúbica en base B
    coefs[[i]] <- coef(interpolated[[i]]) # coeficientes a, b, c, d
  }
  
  return(coefs)
}

coeficientes <- coef_splines(sim)
coeficientes[1]

plot(coeficientes_5[[2]][,2])
points(coeficientes_5[[2]][,3], pch=21, bg = "red")
#points(coeficientes_5[[2]][,4], pch=21, bg = "blue")
```

EXTENCION

```{r}

#EXTENDER EL MODELO AGREGANDO SEXO BIOLOGICO y EDAD
ABM_ext3 <- function(K, iter, p_death, p_birth, r = 1, plot = FALSE) {
  
  habSize <- ceiling(sqrt(K))
  L <- habSize^2
  habitat <- rep(0, L)
  
  N0 <- round(0.05 * K) #Para evitar extincion subito inicamos con mas agentes
  
  
  habitat[sample(1:L, N0)] <- 1 
  N <- c() 
  
  #a cada agente inicial le asigno un sexo bio (1= fem 0 = masc) con 50% de prob
  bio_sex <- rep(NA, L)
  bio_sex[which(habitat ==1)] <- rbinom(N0, 1, 0.5)
  
  #los N0 arrancan tambien con edad cero "recien colocado", se podria asignar una edad aleatroia
  #la edad maxima es la cantidad de iteraciones / lapso max de tiempo
  edad <- rep(0, L) 
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) 
    
    #ENVEJECER 
    edad[vivos] <- edad[vivos] + 1
    
    #MUERTE
    
    for(agente in vivos){
       #riesgo: p_death base * (1 + a * edad / edad_max) // edad_max = iter
      p_death_eff <- p_death * (1 + r * (edad[agente] / iter))
      p_death_eff <- min(p_death_eff, 1)  # evitar >1
      
      if( runif(1) < p_death){
        habitat[agente] <- 0
        bio_sex[agente] <- NA
        edad[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    
    n <- sum(habitat == 1) 
    p_birth_K <- p_birth*(1 - n / K) 
    
    for(agent in vivos){
      if(!is.na(bio_sex[agent]) & bio_sex[agent] == 1) {
        if (runif(1) < p_birth_K){
            libres <- which(habitat == 0) 
            if(length(libres) > 0){ 
              i <- sample(libres, 1)
              habitat[i]  <- 1 
              bio_sex[i] <- rbinom(1, 1, 0.5)
              edad[i] <- 0
            }
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    
    if(plot) {
    
    plot_grid <- rep(0, L)
    plot_grid[which(habitat == 1 & bio_sex == 0)] <- 1
    plot_grid[which(habitat == 1 & bio_sex == 1)] <- 2
    
    
    if(t %in% seq(1, iter - iter/2, by = 5)){
        
      habCuadrado <- matrix(plot_grid, nrow=habSize, byrow=TRUE)
      image(habCuadrado, col = c("white", "pink", "purple"), axes = FALSE, asp = 1)
      #title(main = paste("Iteración", t, " - N =", N[length(N)]))
    }
    
    }
  
}
  
return(N)
  
}


N <- ABM_ext3(500, 60, 0.1, 0.9)


plot(N, type="p", 
       xlab="Tiempo", ylab="Población N(t)",
       main="ABM - Crecimiento Logístico")


#HACER SEXO FIGURA Y EDAD GRADIENTE 
#PARALELIZAR LA SENSIBILIDAD
#PASAR A 2D CON COLOR! INCLUIR IC 

```

ANALISIS DE SENSIBILIDAD

Barrido con p_death variable y p_birth fijo (0.9)

```{r}

set.seed(1234)

#arrancar con 10

sensibilidad <- function(K = 500, iter = 60, p_birth = 0.9, reps = 50){
  t_inicial <- Sys.time()
  p_death <- seq(0, 0.5, by = 0.05)
  p_len <- length(p_death) #cauntos valores distintos de p
  
  #Monitorear
  extincion <- numeric(p_len)
  t_hasta_ext_prom <- numeric(p_len)
  
  #PARA LUEGO GRAFICAR NECESITAMOS PROMEDIAR LAS REPS
  mean_N <- matrix(0, nrow = iter, ncol = p_len)
  var_N <- matrix(0, nrow = iter, ncol = p_len)
  
  
  for(i in 1:p_len) {
    
    pd <- p_death[i]
    #guardar la serie de cada corrida
    runs <- matrix(NA, nrow = reps, ncol = iter)
    
    t_ext <- rep(Inf, reps) #si no extincion t = Inf
    
    for(r in 1:reps){
      N_t <- ABM_ext3(K, iter, pd, p_birth)
      runs[r, ] <- N_t
      
       if(any(N_t == 0)) { #primer instante donde la poblacion = 0
        t_ext[r] <- which(N_t == 0)[1]
      }
    }
    
     extincion[i] <- mean(t_ext < Inf)
     t_hasta_ext_prom[i] <- ifelse(all(extincion[i] == 0), 
                                  NA, 
                                  mean(t_ext[t_ext < Inf]))
     
     mean_N[ ,i] <- colMeans(runs)
     var_N[ ,i] <- apply(runs, 2, var)
    
  }
  
   list(p_death = p_death,
       mean_N = mean_N,
       var_N = var_N,
       extincion_prob = extincion,
       t_hasta_ext_prom = t_hasta_ext_prom,
       t_ej = (t_inicial - Sys.time()))
 
}

res <- sensibilidad()

#dos dimension con IC!!! buscar formato 
#cortar en un tiempo // la banda!! 
#HACER ZOOM EN 2-3 

res$t_ej


```

PARALELIZAR

```{r}

library(parallel)

sens_paral <- function(K = 500, iter = 60, p_birth = 0.9, reps = 50, 
                       p_death = seq(0, 0.5, by = 0.01)) {
  
  t0 <- Sys.time()
  p_len <- length(p_death)
  
  cores <- detectCores() - 1
  cl <- makeCluster(cores)
  
  # Exportar funciones necesarias
  clusterExport(cl, 
                varlist = c("ABM_ext3"),
                envir = .GlobalEnv)
  #clusterSetRNGStream(cl, iseed = seed)
  
  
  # Objetos salida
  mean_N <- matrix(0, nrow = iter, ncol = p_len) 
  #Para graficar usar promedio por punto
  var_N  <- matrix(0, nrow = iter, ncol = p_len)
  extincion <- numeric(p_len)
  t_hasta_ext_prom <- numeric(p_len)
  
  for (i in 1:p_len) {
    pd <- p_death[i]
    
    # Ejecutar reps en paralelo
    runs_list <- parLapply(cl, 1:reps, function(r) {
      ABM_ext3(K = K, iter = iter, p_death = pd, p_birth = p_birth)
    })
    
    # Pasar lista a matriz reps × iter
    runs <- do.call(rbind, runs_list)
    
    # Estadísticas
    mean_N[ ,i] <- colMeans(runs)
    var_N[ ,i]  <- apply(runs, 2, var)
    
    # Extinción
    t_ext <- apply(runs, 1, function(x) {
      if(any(x == 0)) which(x == 0)[1] else Inf
    })
    
    extincion[i] <- mean(t_ext < Inf)
    t_hasta_ext_prom[i] <- ifelse(any(t_ext < Inf),
                                  mean(t_ext[t_ext < Inf]),
                                  NA)
  }
  
  stopCluster(cl)
  
  list(p_death = p_death,
       mean_N = mean_N,
       var_N = var_N,
       extincion_prob = extincion,
       t_hasta_ext_prom = t_hasta_ext_prom,
       t_eje = (t_inicial - Sys.time()))
}

res1<- sens_paral()


res1$t_eje

res1$mean_N[, 3]
hist(res1$mean_N[, 3])

#MEJOR PARA MAS REPS
```

```{r, warning=FALSE}


#Visualizacion
library(tidyverse)

#Mean_N es una matriz --> pasar a formato long

df_long <- data.frame(
  time = rep(1:nrow(res$mean_N), times = length(res$p_death)),
  p_death = rep(res$p_death, each = nrow(res$mean_N)),
  mean = as.vector(res$mean_N),
  var = as.vector(res$var_N)
)

# IC del 95% # n = reps = 50
df_long <- df_long |> 
  mutate(
    sd = sqrt(var),
    se = sd / sqrt(50), #error standar                    
    IC_l = mean - 1.96*se,
    IC_u  = mean + 1.96*se
  )


ggplot(df_long, aes(x = time, y = mean, color = as.factor(p_death))) +
  geom_line(size = 1) +
  labs(color = "p_death",
       x = "Tiempo",
       y = "Población promedio",
       title = "Crecimiento poblacional para distintos p_death") +
  theme_minimal()
#INTENTAR GRAFICAR CURVA 3D


ggplot(df_long, aes(x = time, y = mean, color = as.factor(p_death), fill = as.factor(p_death))) +
  geom_line(size = 0.5) +
  geom_ribbon(aes(ymin = IC_l, ymax = IC_u), alpha = 0.15, color = NA) +
  labs(color = "p_death", fill = "p_death",
       x = "Tiempo",
       y = "Población promedio ± IC95%",
       title = "Curvas con intervalos de confianza") +
  theme_minimal()



#suavizar con loess
```

```{r}



pd <- res$p_death #cols x
t <- 1:nrow(res$mean_N) #filas y
z <- res$mean_N

persp(y = pd, x = t, z = z, theta = 0, phi = -9, ticktype = "detailed", expand = 0.5)





#plotly::plot_ly

#Interactivo, rotación libre.

#plot3D::persp3D

#x vec n, y vec m, z matrix mxn

image(t, pd, z, xlab="p_death", ylab="t", main="Mean N(t) heatmap")
contour(t, pd, z, add = TRUE, drawlabels = FALSE)

```

```{r}
library(plotly)


pd <- res$p_death                 # x = columnas
t  <- 1:nrow(res$mean_N)          # y = filas
z  <- res$mean_N                  # matriz filas × columnas

plot_ly() |>
  add_surface(
    x = pd,     # eje X
    y = t,      # eje Y
    z = z       # matriz Z
  ) |>
  layout(
    scene = list(
      xaxis = list(title = "p_death"),
      yaxis = list(title = "t"),
      zaxis = list(title = "N promedio")
    )
  )


```

```{r}
#Graficar el p_birth_eff, p_death_eff
#SENSIBILIDAD MULTIVARIADA CON CORTE TRANSVERSAL
#OJO CON LAS REPS




```
