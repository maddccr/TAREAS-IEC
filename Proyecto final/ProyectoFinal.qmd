---
title: "ProyectoFinal"
format: html
editor: visual
---

## Proyecto Final - IEC 2025

# *Simulación de un modelo de crecimiento logístico mediante ABM*

## ABM - Base

```{r, warning=FALSE, message=FALSE}
#librerias
library(tidyverse)
library(parallel)
library(viridis)
library(splines)
set.seed(1234)
```

```{r}

ABM_base <- function(K, iter, p_death, p_birth, plot = FALSE) {
#K --> capacidad de carga del ambiente 
#iter --> numero de iteraciones // pasos de tiempo
#p_birth y p_death probabilidad inicial de reproduccion y muerte 
#N --> cantidad de individuos (variable de salida)
  
  #Inicializar el ABM
  #Creacion del ambiente
  
  habSize <- ceiling(sqrt(K)) #quemos una grilla LxL que pueda ocupar K individuos
  L <- habSize^2
  habitat <- rep(0, L) #habitad vacia
  
  #Cantidad inicial de agentes (1%)
  N0 <- round(0.01 * K) #se podria incorporar como parametro
  
  #Posicionar de forma aleatoria
  habitat[sample(1:L, N0)] <- 1 #1 = lleno
  
  #Lo que se busca monitonear es la cantidad de agentes en el tiempo
  N <- c() #crecieminto dinamico
  p_b <- c() #registrar variacion de la p_birth efectiva

  
  #ahora si
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) #recuperar los indices donde el hab esta ocupado
    
    #MUERTES: a cada agente vivo se le asigna una probabilidad a partir de una unif(0,1). Si p < p_death --> r.i.p (equivalente a una ber(p))
    
    for(agente in vivos){
      if( runif(1) < p_death){
        habitat[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    #para simular el compartamiento logistico es necesario que la p_birth sea controlada por la carga del ambiente
    
    n <- sum(habitat == 1) #sumamos los vivos
    p_birth_K <- p_birth*(1 - n / K) #por la limitaciones de la carga, a medida que aumenta N, disminuye la prob de reproducirse
    
    
    for(agent in vivos){
      if (runif(1) < p_birth_K){
        libres <- which(habitat == 0) #ind de espacios libres en la grilla
        if(length(libres) > 0){ 
        habitat[sample(libres, 1)]  <- 1 #elijo un ind aleatorio para colocar
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    p_b <- c(p_b, p_birth_K)
  
    if(plot){ #graficar para cortes de tiempo // se ve como un QR:(
      if(t %in% seq(1, iter - iter/2, by = 5)){
         habCuadrado <- matrix(habitat, nrow=habSize, byrow=TRUE)
         image(habCuadrado, col = c("white","black"), axes = FALSE, asp = 1)
      }
    }

  }
  
df_N <- data.frame(N = N,
                   p = p_b,
                   t = 1:iter)

return(list( N = N,
             p_birth_eff = p_b,
             df_N = df_N))  
  
}
```

```{r}
K <- 100
iter <- 50

set.seed(1234)
ABM_1 <- ABM_base(K, iter, 0.1, 0.9)
#los parametros que contralan la mortalidad y la natalidad los inicializamos de forma optima, dado que van a ir "empeorando" con el tiempo

set.seed(1234)
ABM_2 <- ABM_base(K, iter, 0.3, 0.8)

df <- bind_rows(
  ABM_1$df_N |>  mutate(simu = "pD=0.1, pB=0.9"),
  ABM_2$df_N |>  mutate(simu = "pD=0.3, pB=0.8")
)

ggplot(df) + geom_point(aes(x = t, y = N, color = simu, shape = "N")) +
  geom_point(aes(x = t, y = p*max(N), color = simu, shape = "pB efectiva"),
             size = 0.8) +
  labs(title = "Evolución en el tiempo de la población \n y la probabilidad efectiva de reproducción", subtitle = "(ABM base)",
       x = "Tiempo", 
       y = "Población N(t)\n Probabilidad de reproducción (%)", 
       color = "Parámetros") +
  scale_color_manual( values = viridis(20)[c(2,13)], name = "Simulación") +
  #scale_color_viridis(discrete = TRUE, option = "D") +
  scale_shape_manual(values = c("N" = 16, "pB efectiva" = 17),
    name = "Variable") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 13, hjust = 0.5),
        legend.position = "bottom")
 
```

### Solución de la EDO

```{r}
#La EDO tiene sol analitica
sol_EDO <- function(t, K, N0, r) {
  (K*N0*exp(r*t))/ (K + N0*(exp(r*t) - 1))
}

sols <-function(t, K, N0, r) {
  soluciones <- c()
  for (i in 1:t) {
    soluciones <- c(soluciones, sol_EDO(i, K, N0, r))
  }
  return(soluciones)
}

soluciones <- sols(iter, K, 1, 0.8) 
#r = pB - pD
#lines(t, sols, type = "l")
```

```{r}
#Para paremtros optimos realizamos n replicas

simulacion_n <- function(n){
  sims <- matrix(NA, nrow = n, ncol = iter) 
  for (i in 1:n) {
    res <- ABM_base(K, iter, 0.1, 0.9)
    sims [i, ] <- res$N
  }
  return(sims)
}
```

### Análisis de convergencia 

```{r}
#Necesitamos determinar el numero de replicas adecuado
#Analisis de convergencia 

analisis_conver <- function(sims){
  #Metrica: N final
final_N <- sims[, iter] 
acum_mean <- cumsum(final_N)/(1:length(final_N))

#Agregamos ademas medidas de dispersion 
acum_var <- sapply(1:length(final_N), function(m){
  var(final_N[1:m])/m
})

acum_se <- sqrt(acum_var) #error estandar 


df <- data.frame(
  replicas = 1:length(acum_mean),
  mean = acum_mean,
  se = acum_se)
  
}
```

```{r, warning=FALSE}
#Por sensibilidad del modelo a la incializacion de los numeros aleatorios comparamos dos semillas

set.seed(1234)
sims_1 <- simulacion_n(200) 
df_1 <- analisis_conver(sims_1)
df_1$sim <- "seed_1234"
mu_1 <- mean(sims_1[, iter])

set.seed(1)
sims_2 <- simulacion_n(200) 
df_2 <- analisis_conver(sims_2)
df_2$sim <- "seed_1"
mu_2 <- mean(sims_2[, iter])

df_ambas <- rbind(df_1, df_2)


ggplot(df_ambas, aes(x = replicas, y = mean, color = sim, fill = sim)) +
  #"banda" de confianza asumiendo aproximacion normal 
  geom_ribbon(aes(ymin = mean - 1.96*se, 
                  ymax = mean + 1.96*se), 
              alpha = 0.2, color = NA) +
  
  geom_line(size = 0.8) +
  #promedio total
  geom_hline(yintercept = mu_1, linetype = "dashed") +
  geom_hline(yintercept = mu_2, linetype = "dashed") +
  
  geom_text(inherit.aes = FALSE, aes(x = -1, y = mu_1, label = round(mu_1, 1)),
            vjust = -0.4, hjust = 1, size = 3, fontface = "plain",
            alpha = 0.7) +
  
  scale_color_manual(values = c(viridis(20)[13], viridis(20)[2])) +
  scale_fill_manual(values = c(viridis(20)[13], viridis(20)[2])) +
  
  scale_y_continuous(limits = c(0, 125)) +
  
  labs(title = "Convergencia del N(t) en el tiempo final para dos semillas",
       subtitle = "(ABM base)",
       x= "Número de réplicas",
       y = "Promedio acumulado",
       color = "Semilla", fill = "Semilla",
       caption = paste0("Promedio total seed_1: ", round(mu_1, 2),"     |     ",
                        "Promedio total seed_1234: ", round(mu_2, 2))) +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 13, hjust = 0.5),
        plot.caption = element_text(size = 8, hjust = 0.5, face = "italic"),
        legend.position = "bottom")


```

```{r}

#Se estabiliza en n > 50
set.seed(1234)
sim <- simulacion_n(60)

#INTERPOLACION
interpolar_sims <- function(sims) {
  n <- nrow(sims)
  t <- 1:ncol(sims)
  interpolated <- matrix(NA, nrow = n, ncol = 200)
  for (i in 1:n) {
    new_points<- spline(t, sims[i,], 200)
    interpolated [i,] <- new_points$y
  }
  return(interpolated)
}

sim_splines <- interpolar_sims(sim)
```

```{r}

df_sim1 <- data.frame(
  t = 1:length(sim[1, ]),
  N = sim[1, ]
)

df_EDO <- data.frame(
  t = 1:length(sim[1, ]),
  N_EDO = soluciones
)

sim_matrix <- sim_splines # matriz nSim x nPuntos (200)
t200 <- seq(1, iter, length.out = 200)


nSim <- nrow(sim_splines)

mean_interp <- apply(sim_splines, 2, mean)
var_interp  <- apply(sim_splines, 2, var)
se_interp   <- sqrt(var_interp / nSim)
mean(se_interp)

# Banda de confianza 95%
ribbon_df <- data.frame(
  t    = t200,
  ymin = mean_interp - 1.96 * se_interp,
  ymax = mean_interp + 1.96 * se_interp
)

df_spline <- sim_splines |> as.data.frame() |> setNames(1:200) |> 
  mutate(sim = row_number()) |> 
  pivot_longer(cols = -sim, names_to = "index", values_to = "N_interp") |> 
  mutate(index = as.numeric(index),t = t200[index])



#Para menos ruido grafico se eligen de forma aleatoria
subset_idx <- sample(1:nrow(sim_splines), 12)
df_spline_sub <- df_spline |> filter(sim %in% subset_idx)

ggplot() + geom_point(data = df_sim1, size = 1, alpha = 0.8,
    aes(x = t, y = N, color = "ABM Base")) +
  
           geom_line(data = df_spline |>  filter(sim == 1), size = 1,
    aes(x = t, y = N_interp, color = "Interpolación")) +
  
    scale_color_manual(values = viridis(20)[c(2, 13)],name = "") +
    labs(title = "Simulación (1): Original vs Interpolación", 
          x = "Tiempo", y = "Población N(t)") +
  
    theme_minimal() +
    theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
    legend.position = "bottom")

ggplot() +
  geom_ribbon(data = ribbon_df, aes(x = t, ymin = ymin, ymax = ymax),
              fill = viridis(20)[20], alpha = 0.5) +
  geom_line(data = df_spline_sub, aes(x = t, y = N_interp, group = sim), color=viridis(10)[5], alpha = 0.7) +
  geom_line(data = df_EDO, aes(x = t, y = N_EDO),
            color = "black", size = 0.7) +
  
  scale_color_viridis_c(end = 0.8) +
  labs(title = "Todas las simulaciones interpoladas (spline)",
       x = "Tiempo",y = "Población interpolada") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
    legend.position = "right")


#alpha 0.08 color grey30 para graficar todas

```

```{r}
#coeficientes de los splines
coef_splines <- function(sims) {
  n <- nrow(sims)
  t <- 1:ncol(sims)
  interpolated <- vector("list", n)
  poly_spline <- vector("list", n)
  coefs <- vector("list", n)
  
  for (i in 1:n) {
    interpolated[[i]] <- interpSpline(t, sims[i,]) # spline cúbica en base B
    coefs[[i]] <- coef(interpolated[[i]]) # coeficientes a, b, c, d
  }
  
  return(coefs)
}

coeficientes <- coef_splines(sim)

#estudio de coeficientes

#cada coeficiente por separado
coefs_A <- function(coeficientes) {
  n_sims <- length(coeficientes)
  t <- nrow(coeficientes[[1]])
  
  coefs_mat <- matrix(NA, nrow = n_sims * t, ncol = 4)
  
  fila <- 1
  
  for (i in 1:n_sims) {
    coef_i <- coeficientes[[i]]  # matriz 60 × 4
    
    coefs_mat[fila:(fila + t - 1), ] <- coef_i
    
    fila <- fila + t
  }
  
  colnames(coefs_mat) <- c("A", "B", "C", "D")
  
  return(coefs_mat)
}

coef_globales <- coefs_A(coeficientes)

summary(coef_globales)
sd_B <- sd(coef_globales[,2])
sd_C <- sd(coef_globales[,3])

# Graficarlos con facet_wrap
coef_glob_df <- as.data.frame(coef_globales)
coef_long <- pivot_longer(coef_glob_df, cols = A:D, names_to = "coef", values_to = "valor")


ggplot(coef_long, aes(x = valor)) +
  geom_histogram(fill = viridis(20)[13], color = "black") +
  facet_wrap(~coef, scales = "free") +
  theme_minimal() +
  labs(x = "Valor del coeficiente", y = "Frecuencia",
       title = "Distribución de los coeficientes de interpolación") +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
    legend.position = "right")

#coeficientes por simulacion y relacion entre simulaciones
coefs_B <-function(coeficientes) {
  n_sims <- length(coeficientes)
  coefs_mat <- matrix(NA, nrow = length(coeficientes), ncol = 4*60)
  
  for (i in 1:n_sims) {
    coefs_i <- coeficientes[[i]]
    coefs_mat[i,] <- as.vector(t(coefs_i))
  }
  return(coefs_mat)
}


coefs_por_sim <- coefs_B(coeficientes)
coefs_por_sim_df <- as.data.frame(coefs_por_sim)

distancias <- dist(coefs_por_sim) #entrada  (i,j) indica qué tan distinta es la simulación i de la j según sus 240 coeficientes del spline
dist_vec <- as.numeric(distancias) #paso el objeto dist a num
df_dist <- data.frame(distancia = dist_vec) #df con todas las distsncias entre simulaciones
dist_matrix <- as.matrix(distancias)
which(dist_matrix == 718.30, arr.ind = TRUE)

summary(dist_vec)
sd(dist_vec)

dist_norm <- (dist_vec - min(dist_vec)) / (max(dist_vec) - min(dist_vec))
df_dist_norm <- data.frame(distancia = dist_norm)
summary(dist_norm)
sd(dist_norm)

#este no entiendo

ggplot(df_dist_norm) +
  geom_histogram(aes(x=distancia), bins = 60, fill=viridis(20)[2], color = "black") +
  labs(title = "Distancia entre simulaciones estandarizada", x="Distancia" , y= "Distribución")+
  theme_minimal()

#boxplot por posible presencia de outliers

```

## ABM - Extendido (edad y sexo biológico)

```{r}
ABM_ext <- function(K, iter, p_death, p_birth, r = 1, plot = FALSE) {
  
  timestamps <- c(1, 4, 7, 10, 13, 16, 19, 21, iter)
  timestamps_plot <- list()
  
  
  habSize <- ceiling(sqrt(K))
  L <- habSize^2
  habitat <- rep(0, L)
  
  N0 <- round(0.05 * K) #Para evitar extincion subita inicamos con mas agentes
  
  habitat[sample(1:L, N0)] <- 1 
  N <- c() 
  
  #a cada agente inicial le asigno un sexo bio (1= fem 0 = masc) con ber(0.5)
  bio_sex <- rep(NA, L)
  bio_sex[which(habitat ==1)] <- rbinom(N0, 1, 0.5)
  
  #los N0 arrancan tambien con edad cero "recien colocado"
  #la edad maxima es la cantidad de iteraciones / lapso max de tiempo
  edad <- rep(0, L) 
  
  for(t in 1:iter){
    
    vivos <- which(habitat == 1) 
    
    #ENVEJECER 
    edad[vivos] <- edad[vivos] + 1
    
    #MUERTE
    
    for(agente in vivos){
       #riesgo: p_death base * (1 + r * edad / edad_max) // edad_max = iter
      p_death_eff <- p_death * (1 + r * (edad[agente] / iter))
      p_death_eff <- min(p_death_eff, 1)  # evitar >1
      
      if( runif(1) < p_death){
        habitat[agente] <- 0
        bio_sex[agente] <- NA
        edad[agente] <- 0
      }
    }
    
    #NACIMIENTOS 
    
    n <- sum(habitat == 1) 
    p_birth_K <- p_birth*(1 - n / K) 
    
    for(agent in vivos){
      if(!is.na(bio_sex[agent]) & bio_sex[agent] == 1) {
        if (runif(1) < p_birth_K){
            libres <- which(habitat == 0) 
            if(length(libres) > 0){ 
              i <- sample(libres, 1)
              habitat[i]  <- 1 
              bio_sex[i] <- rbinom(1, 1, 0.5)
              edad[i] <- 0
            }
        }
      }
    }
    
  #Actualizar la cantidad de agentes
    
    N <- c(N, sum(habitat == 1))
    
    if(plot) {
    
    plot_grid <- rep(0, L)
    plot_grid[which(habitat == 1 & bio_sex == 0)] <- 1
    plot_grid[which(habitat == 1 & bio_sex == 1)] <- 2
    
    
    if(t %in% timestamps){
        
      habCuadrado <- matrix(plot_grid, nrow=habSize, byrow=TRUE)
      timestamps_plot[[as.character(t)]] <- list(grid = habCuadrado)
      #title(main = paste("Iteración", t, " - N =", N[length(N)]))
    }
    
    }
  
}
  
return(list(N = N, plot = timestamps_plot))
  
}

```

```{r}
K <- 500
ABM_3 <- ABM_ext(K, 60, 0.1, 0.9, plot = TRUE)

par(mfrow=c(3,3), mar=c(2,2,2,2))
for(name in names(ABM_3$plot)){
  
  grid <- ABM_3$plot[[name]]$grid
  
  image(grid[nrow(grid):1,], col=c("white", viridis(20)[2], viridis(20)[13]), 
        axes=FALSE, asp = 1)
  title(paste("t =", name))
  
  # Calcular %
  n_SM <- sum(grid == 1)
  n_SF <- sum(grid == 2)
  n_total <- n_SM + n_SF
  ocupacion <- round(100 * n_total / K, 1)
  prop_SM <- round(100 * n_SM / n_total, 1)
  prop_SF <- round(100 * n_SF / n_total, 1)
  
    # Texto debajo en negrita
  mtext(paste0("N/K: ", ocupacion, "% | SM: ", prop_SM,
               "% | SF: ", prop_SF, "%"), side=1, line=0.5, cex=0.65, font=2)
  legend("bottomright", legend=c("SM","SF"), 
         fill= c(viridis(20)[2], viridis(20)[13]), bty="n", cex=0.8)
}

```

```{r}
#GRAFICAR CURVA
```

### Análisis de sensibilidad

```{r}
#Barrido con p_death variable y p_birth fijo (0.9)
#codigo palelizado para mayor eficiencia
sens_paral <- function(K = 500, iter = 60, p_birth = 0.9, reps = 100, 
                       p_death = seq(0, 0.5, by = 0.05)) {
  
  t0 <- Sys.time()
  p_len <- length(p_death)
  
  cores <- detectCores() - 1
  cl <- makeCluster(cores)
  
  #Exportar funciones necesarias
  clusterExport(cl,varlist = c("ABM_ext"),envir = .GlobalEnv)
  clusterSetRNGStream(cl, 123)
  #clusterSetRNGStream(cl, iseed = seed)
  
  #Monitorear
  extincion <- numeric(p_len)
  t_hasta_ext_prom <- numeric(p_len)
  
  #PARA LUEGO GRAFICAR NECESITAMOS PROMEDIAR LAS REPS (punto a punto)
  mean_N <- matrix(0, nrow = iter, ncol = p_len)
  var_N <- matrix(0, nrow = iter, ncol = p_len)
  
  for (i in 1:p_len) {
    pd <- p_death[i]
    
    #Ejecutar reps en paralelo
    runs_list <- parLapply(cl, 1:reps, function(r) {
      ABM_ext(K = K, iter = iter, p_death = pd, p_birth = p_birth)$N
    })
    
    #Pasar lista a matriz reps × iter
    runs <- do.call(rbind, runs_list)
    
    mean_N[ ,i] <- colMeans(runs)
    var_N[ ,i]  <- apply(runs, 2, var)
    
    #Extinción
    t_ext <- apply(runs, 1, function(x) {
      if(any(x == 0)) which(x == 0)[1] else Inf
    })
    
    extincion[i] <- mean(t_ext < Inf)
    t_hasta_ext_prom[i] <- ifelse(all(extincion[i] == 0), 
                                  NA, 
                                  mean(t_ext[t_ext < Inf]))
  }
  
  stopCluster(cl)
  
  list(p_death = p_death,
       mean_N = mean_N,
       var_N = var_N,
       extincion_prob = extincion,
       t_hasta_ext_prom = t_hasta_ext_prom,
       t_eje = (t0 - Sys.time()))
}


```

```{r}
#Analisis de convergencia para ABM extendido

simulacion_ext <- function(n){
  sims <- matrix(NA, nrow = n, ncol = 60) #iter = 60
  for (i in 1:n) {
    res <- ABM_ext(500, 60, 0.1, 0.9)
    sims [i, ] <- res$N
  }
  return(sims)
}


runs <- simulacion_ext(200)
final_N <- runs[, 60] #metrica N(t) final


#running_var <- cumsum((vals - running_mean)^2) / (1:length(vals))
running_mean <- cumsum(final_N)/(1:length(final_N))

running_var <- sapply(1:length(final_N), function(m){
  var(final_N[1:m])/m
})
running_se <- sqrt(running_var)


df_rm <- data.frame(
  replicas = 1:length(running_mean),
  mean = running_mean,
  se = running_se)

ggplot(df_rm, aes(x = replicas, y = mean)) +
  geom_ribbon(aes(ymin = mean - 1.96*se, ymax = mean + 1.96*se), 
              alpha = 0.3, fill = viridis(20)[13]) +
  geom_line(color = viridis(20)[2], size = 0.8) +
  geom_hline(yintercept = mean(final_N), linetype = "dashed") +
  labs(title = "Convergencia del N(t) final (running mean)",
       x= "Número de réplicas",
       y = "Promedio acumulado") +
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
        legend.position = "bottom")


```

```{r, warning=FALSE}


res <- sens_paral(p_death = seq(0.2, 0.35, by = 0.005), iter = 100)


```

```{r}

#Mean_N es una matriz --> pasar a formato long
df_long <- data.frame(
  time = rep(1:nrow(res$mean_N), times = length(res$p_death)),
  p_death = rep(res$p_death, each = nrow(res$mean_N)),
  mean = as.vector(res$mean_N),
  var = as.vector(res$var_N),
  se = sqrt(as.vector(res$var_N) / 100) #reps = 100
)

N0 <- round(0.05 * 500) 

ggplot(df_long, aes(x = time, y = mean, color = p_death, group = p_death)) +
  geom_ribbon(aes(ymin = mean - 1.96*se, ymax = mean + 1.96*se,
                  fill = p_death), alpha = 0.15, color = NA) +
  geom_line(size = 0.8) +
  geom_hline(yintercept = N0, linetype = "dashed", size = 1) +
  labs(color = "p_death",
       x = "Tiempo",
       y = "Población promedio",
       title = "Crecimiento poblacional para distintos p_death") +
  scale_color_viridis_c(option = "D") +
  scale_fill_viridis_c() +
  guides(fill = "none") +  
  theme_minimal() +
  theme(plot.title = element_text(size = 15, face = "bold", hjust = 0.5),
        legend.position = "right")

```

```{r}
#SENSIBILIDAD MULTIVARIADA CON CORTE TRANSVERSAL




```
