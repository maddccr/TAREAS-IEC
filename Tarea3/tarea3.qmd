---
title: "tarea3"
format: html
editor: visual
---

Ejercicio 8

Modificacion de la funcion fixedpoint (10.2) para funciones de Rd en Rd. Cambiamo la funcion abs() por norm()

```{r}

#funcion sacada del libro:
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {

 # applies the fixed-point algorithm to find x such that ftn(x) == x
 # ftn  R^d -> R^d, d > 1.
 # x0 is the initial guess at the fixed point
 #LA FUNCION NORM CALCULA LA NORMA DE VECTORES
 
 xold <- x0
 xnew <- ftn(xold)
 iter <- 1
 cat("At iteration 1 value of x is:", xnew, "\n")
 #modificamos abs por norm
 while ((norm(as.matrix(xnew-xold)) > tol) && (iter < max.iter)) {
 xold <- xnew;
 xnew <- ftn(xold);
 iter <- iter + 1
 cat("At iteration", iter, "value of x is:", xnew, "\n")
 }
 # output depends on success of algorithm
 if (norm(as.matrix(xnew-xold)) > tol) {
 cat("Algorithm failed to converge\n")
 return(NULL)
 } else {
 cat("Algorithm converged\n")
 return(xnew)
 }
}

#definir la funcion para evaluar
f <- function(x){
  c(log(1 + x[1] + x[2]), log(5 - x[1] - x[2]))
}

x0 <- c(1,1)

fixedpoint(f, x0)
```

Ejercicio 6 - secant method

```{r}

secant <- function(ftn, x0, x1, tol = 1e-9, max.iter = 100) {
 

 xold1 <- x0
 xold2 <- x1
 xnew <- ftn(x1)
 
 iter <- 1
 #modificamos abs por norm
 while ((abs(ftn(xnew)) > tol) && (iter < max.iter)) {
 xnew <- xold2 - ftn(xold2)*((xold2 - xold1)/(ftn(xold2) - ftn(xold1)))
 xold1 <- xold2
 xold2 <- xnew
 iter <- iter + 1
 cat("At iteration", iter, "value of x is:", xnew, "\n")
 }
 # output depends on success of algorithm
 if ((abs(ftn(xnew)) > tol)) {
 cat("Algorithm failed to converge\n")
 return(NULL)
 } else {
 cat("Algorithm converged\n")
 return(xnew)
 }
}

f <- function(x) cos(x) - x
f1 <- function(x) log(x) - exp(-x)

secant(f, 1, 3)
secant(f1, 1, 2)

```

Comparar performe con la funcion de NR

```{r}

#FUNCION DEL LIBRO
newtonraphson <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
 # Newton_Raphson algorithm for solving ftn(x)[1] == 0
 # we assume that ftn is a function of a single variable that returns
 # the function value and the first derivative as a vector of length 2
 #
 # x0 is the initial guess at the root
 # the algorithm terminates when the function value is within distance
 # tol of 0, or the number of iterations exceeds max.iter
 # initialise
 x <- x0
 fx <- ftn(x)
 iter <- 0
 # continue iterating until stopping conditions are met
 while ((abs(fx[1]) > tol) && (iter < max.iter)) {
 x <- x- fx[1]/fx[2]
 fx <- ftn(x)
 iter <- iter + 1
 cat("At iteration", iter, "value of x is:", x, "\n")
 }
 # output depends on success of algorithm
 if (abs(fx[1]) > tol) {
 cat("Algorithm failed to converge\n")
 return(NULL)
 } else {
 cat("Algorithm converged\n")
 return(x)
 }
}

f <- function(x) {
 fx <- cos(x) - x
 dfx <- -sin(x) -1
 return(c(fx, dfx))
 }

f1 <- function(x) {
 fx <- log(x)- exp(-x)
 dfx <- 1/x + exp(-x)
 return(c(fx, dfx))
 }

newtonraphson(f, 1) 
newtonraphson(f1, 1) 
```
